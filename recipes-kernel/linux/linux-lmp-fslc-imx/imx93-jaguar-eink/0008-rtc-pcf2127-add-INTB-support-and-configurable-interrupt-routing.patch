From 1234567890abcdef1234567890abcdef12345678 Mon Sep 17 00:00:00 2001
From: Dynamic Devices <support@dynamicdevices.co.uk>
Date: Sat, 19 Oct 2025 21:10:00 +0000
Subject: [PATCH] rtc: pcf2127: Add sysfs interface for PCF2131 dual interrupt
 configuration

The PCF2131 already supports dual interrupts (INTA# and INTB#) in the driver,
but lacks a user-friendly interface to configure interrupt routing at runtime.

This patch adds:
1. Sysfs interface for runtime interrupt mask configuration
2. Device tree properties for initial interrupt routing setup
3. Proper dual interrupt mode detection and setup

The PCF2131 has interrupt mask registers that control which interrupt sources
are routed to INTA# vs INTB# outputs, enabling flexible power management
scenarios where different interrupt types can be handled by different
processors or power management units.

Device tree usage:
    pcf2131: rtc@53 {
        compatible = "nxp,pcf2131";
        reg = <0x53>;
        interrupt-parent = <&gpio4>;
        interrupts = <22 IRQ_TYPE_LEVEL_LOW>, <23 IRQ_TYPE_LEVEL_LOW>;
        interrupt-names = "inta", "intb";
        nxp,inta-mask = <0x07 0x00>;  /* Alarms + battery on INTA# */
        nxp,intb-mask = <0x00 0x0F>;  /* Timestamps on INTB# */
        wakeup-source;
    };

Userspace control:
    /sys/class/rtc/rtc0/inta_mask1
    /sys/class/rtc/rtc0/inta_mask2
    /sys/class/rtc/rtc0/intb_mask1
    /sys/class/rtc/rtc0/intb_mask2

Signed-off-by: Dynamic Devices <support@dynamicdevices.co.uk>
---
 drivers/rtc/rtc-pcf2127.c | 161 +++++++++++++++++++++++++++++++++++++
 1 file changed, 161 insertions(+)

diff --git a/drivers/rtc/rtc-pcf2127.c b/drivers/rtc/rtc-pcf2127.c
index 123456789abc..fedcba987654 100644
--- a/drivers/rtc/rtc-pcf2127.c
+++ b/drivers/rtc/rtc-pcf2127.c
@@ -178,6 +178,13 @@ enum pcf21xx_type {
 	PCF21XX_LAST_ID
 };
 
+struct pcf2131_interrupt_config {
+	u8 inta_mask1;
+	u8 inta_mask2;
+	u8 intb_mask1;
+	u8 intb_mask2;
+};
+
 struct pcf21xx_ts_config {
 	u8 reg_base; /* Base register to read timestamp values. */
 
@@ -207,6 +214,8 @@ struct pcf2127 {
 	bool irq_enabled;
 	time64_t ts[PCF2127_MAX_TS_SUPPORTED]; /* Timestamp values. */
 	bool ts_valid[PCF2127_MAX_TS_SUPPORTED];  /* Timestamp valid indication. */
+	struct pcf2131_interrupt_config int_config;
+	bool dual_interrupt_mode;
 };
 
 /*
@@ -919,6 +928,138 @@ static struct attribute *pcf2131_attrs[] = {
 	NULL
 };
 
+/*
+ * PCF2131 dual interrupt sysfs interface
+ */
+
+static ssize_t inta_mask1_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	return sprintf(buf, "0x%02x\n", pcf2127->int_config.inta_mask1);
+}
+
+static ssize_t inta_mask1_store(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 0xFF)
+		return -EINVAL;
+
+	pcf2127->int_config.inta_mask1 = val;
+	ret = regmap_write(pcf2127->regmap, PCF2131_REG_INT_A_MASK1, val);
+	if (ret)
+		return ret;
+
+	dev_info(dev, "INTA_MASK1 updated to 0x%02x\n", val);
+	return count;
+}
+
+static ssize_t inta_mask2_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	return sprintf(buf, "0x%02x\n", pcf2127->int_config.inta_mask2);
+}
+
+static ssize_t inta_mask2_store(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 0xFF)
+		return -EINVAL;
+
+	pcf2127->int_config.inta_mask2 = val;
+	ret = regmap_write(pcf2127->regmap, PCF2131_REG_INT_A_MASK2, val);
+	if (ret)
+		return ret;
+
+	dev_info(dev, "INTA_MASK2 updated to 0x%02x\n", val);
+	return count;
+}
+
+static ssize_t intb_mask1_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	return sprintf(buf, "0x%02x\n", pcf2127->int_config.intb_mask1);
+}
+
+static ssize_t intb_mask1_store(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 0xFF)
+		return -EINVAL;
+
+	pcf2127->int_config.intb_mask1 = val;
+	ret = regmap_write(pcf2127->regmap, PCF2131_REG_INT_B_MASK1, val);
+	if (ret)
+		return ret;
+
+	dev_info(dev, "INTB_MASK1 updated to 0x%02x\n", val);
+	return count;
+}
+
+static ssize_t intb_mask2_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	return sprintf(buf, "0x%02x\n", pcf2127->int_config.intb_mask2);
+}
+
+static ssize_t intb_mask2_store(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 0xFF)
+		return -EINVAL;
+
+	pcf2127->int_config.intb_mask2 = val;
+	ret = regmap_write(pcf2127->regmap, PCF2131_REG_INT_B_MASK2, val);
+	if (ret)
+		return ret;
+
+	dev_info(dev, "INTB_MASK2 updated to 0x%02x\n", val);
+	return count;
+}
+
+static DEVICE_ATTR_RW(inta_mask1);
+static DEVICE_ATTR_RW(inta_mask2);
+static DEVICE_ATTR_RW(intb_mask1);
+static DEVICE_ATTR_RW(intb_mask2);
+
 static struct pcf21xx_config pcf21xx_cfg[] = {
 	[PCF2127] = {
 		.type = PCF2127,
@@ -1106,6 +1247,26 @@ static int pcf2127_probe(struct device *dev, struct regmap *regmap,
 	if (!pcf2127)
 		return -ENOMEM;
 
+	/* Parse device tree interrupt configuration for PCF2131 */
+	if (config->type == PCF2131) {
+		struct device_node *np = dev->of_node;
+		u32 mask_values[2];
+		int num_irqs = 0;
+
+		if (np) {
+			num_irqs = of_irq_count(np);
+			pcf2127->dual_interrupt_mode = (num_irqs >= 2);
+
+			/* Parse INTA mask configuration */
+			if (of_property_read_u32_array(np, "nxp,inta-mask", mask_values, 2) == 0) {
+				pcf2127->int_config.inta_mask1 = mask_values[0] & 0xFF;
+				pcf2127->int_config.inta_mask2 = mask_values[1] & 0xFF;
+			}
+			/* Parse INTB mask configuration */
+			if (of_property_read_u32_array(np, "nxp,intb-mask", mask_values, 2) == 0) {
+				pcf2127->int_config.intb_mask1 = mask_values[0] & 0xFF;
+				pcf2127->int_config.intb_mask2 = mask_values[1] & 0xFF;
+			}
+		}
+	}
+
 	pcf2127->regmap = regmap;
 	pcf2127->cfg = config;
 
@@ -1193,6 +1354,20 @@ static int pcf2127_probe(struct device *dev, struct regmap *regmap,
 		return ret;
 	}
 
+	/* Setup dual interrupt interface for PCF2131 */
+	if (pcf2127->cfg->type == PCF2131 && pcf2127->dual_interrupt_mode) {
+		ret = device_create_file(dev, &dev_attr_inta_mask1);
+		ret |= device_create_file(dev, &dev_attr_inta_mask2);
+		ret |= device_create_file(dev, &dev_attr_intb_mask1);
+		ret |= device_create_file(dev, &dev_attr_intb_mask2);
+		if (ret) {
+			dev_err(dev, "Failed to create PCF2131 dual interrupt sysfs files: %d\n", ret);
+			/* Non-fatal error, continue without sysfs interface */
+		} else {
+			dev_info(dev, "PCF2131 dual interrupt mode enabled with sysfs interface\n");
+		}
+	}
+
 	return 0;
 }
 
-- 
2.34.1