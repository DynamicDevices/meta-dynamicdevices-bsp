Add PCF2131 ultra-low power optimization and SYSFS interface

This patch adds power optimization for the PCF2131 RTC by disabling
temperature compensation (TC_DIS) and 1/100 seconds counter (100TH_S_DIS)
to reduce power consumption from ~770nA to ~400nA.

Additionally, it provides SYSFS interface for:
- INTA/INTB interrupt mask control
- Minute/Second periodic interrupt enable/disable

The optimization is automatically applied during probe for PCF2131 devices.
Periodic interrupts are disabled by default to prevent interrupt storms.

Signed-off-by: Dynamic Devices <support@dynamicdevices.co.uk>

--- a/drivers/rtc/rtc-pcf2127.c
+++ b/drivers/rtc/rtc-pcf2127.c
@@ -32,6 +32,15 @@
 /* Control register 1 */
 #define PCF2127_REG_CTRL1		0x00
 #define PCF2127_BIT_CTRL1_POR_OVRD		BIT(3)
+/* PCF2131 power optimization bits */
+#define PCF2127_BIT_CTRL1_TC_DIS		BIT(6)
+#define PCF2127_BIT_CTRL1_100TH_S_DIS		BIT(3)
+/* PCF2131 periodic interrupt bits */
+#define PCF2127_BIT_CTRL1_MI			BIT(1)
+#define PCF2127_BIT_CTRL1_SI			BIT(0)
+/* PCF2131 interrupt mask registers */
+#define PCF2127_REG_INT_A_MASK1			0x31
+#define PCF2127_REG_INT_B_MASK1			0x33
 #define PCF2127_BIT_CTRL1_TSF1			BIT(4)
 #define PCF2127_BIT_CTRL1_STOP			BIT(5)
 /* Control register 2 */
@@ -1102,6 +1111,120 @@
 	return ret;
 }
 
+/* SYSFS interface for PCF2131 INTA/INTB masks and periodic interrupts */
+
+static ssize_t inta_mask_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = regmap_read(pcf2127->regmap, PCF2127_REG_INT_A_MASK1, &val);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t inta_mask_store(struct device *dev, struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 0xFF)
+		return -EINVAL;
+
+	ret = regmap_write(pcf2127->regmap, PCF2127_REG_INT_A_MASK1, val);
+	if (ret)
+		return ret;
+
+	dev_info(dev, "INTA mask set to 0x%02x\n", val);
+	return count;
+}
+
+static ssize_t intb_mask_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = regmap_read(pcf2127->regmap, PCF2127_REG_INT_B_MASK1, &val);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t intb_mask_store(struct device *dev, struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 0xFF)
+		return -EINVAL;
+
+	ret = regmap_write(pcf2127->regmap, PCF2127_REG_INT_B_MASK1, val);
+	if (ret)
+		return ret;
+
+	dev_info(dev, "INTB mask set to 0x%02x\n", val);
+	return count;
+}
+
+static ssize_t minute_interrupt_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = regmap_read(pcf2127->regmap, PCF2127_REG_CTRL1, &val);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "%d\n", !!(val & PCF2127_BIT_CTRL1_MI));
+}
+
+static ssize_t minute_interrupt_store(struct device *dev, struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 1)
+		return -EINVAL;
+
+	ret = regmap_update_bits(pcf2127->regmap, PCF2127_REG_CTRL1,
+				 PCF2127_BIT_CTRL1_MI,
+				 val ? PCF2127_BIT_CTRL1_MI : 0);
+	if (ret)
+		return ret;
+
+	dev_info(dev, "Minute interrupt %s\n", val ? "enabled" : "disabled");
+	return count;
+}
+
+static ssize_t second_interrupt_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = regmap_read(pcf2127->regmap, PCF2127_REG_CTRL1, &val);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "%d\n", !!(val & PCF2127_BIT_CTRL1_SI));
+}
+
+static ssize_t second_interrupt_store(struct device *dev, struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 1)
+		return -EINVAL;
+
+	ret = regmap_update_bits(pcf2127->regmap, PCF2127_REG_CTRL1,
+				 PCF2127_BIT_CTRL1_SI,
+				 val ? PCF2127_BIT_CTRL1_SI : 0);
+	if (ret)
+		return ret;
+
+	dev_info(dev, "Second interrupt %s\n", val ? "enabled" : "disabled");
+	return count;
+}
+
+/* SYSFS attribute definitions */
+static DEVICE_ATTR_RW(inta_mask);
+static DEVICE_ATTR_RW(intb_mask);
+static DEVICE_ATTR_RW(minute_interrupt);
+static DEVICE_ATTR_RW(second_interrupt);
+
+static struct attribute *pcf2131_sysfs_attrs[] = {
+	&dev_attr_inta_mask.attr,
+	&dev_attr_intb_mask.attr,
+	&dev_attr_minute_interrupt.attr,
+	&dev_attr_second_interrupt.attr,
+	NULL
+};
+
+static const struct attribute_group pcf2131_sysfs_group = {
+	.attrs = pcf2131_sysfs_attrs,
+};
+
+static int pcf2127_sysfs_register(struct device *dev, struct pcf2127 *pcf2127)
+{
+	if (pcf2127->cfg->type == PCF2131) {
+		return sysfs_create_group(&dev->kobj, &pcf2131_sysfs_group);
+	}
+	return 0;
+}
+
 static int pcf2127_probe(struct device *dev, struct regmap *regmap,
 			 int alarm_irq, const struct pcf21xx_config *config)
 {
@@ -1235,6 +1358,20 @@
 
 	pcf2127_watchdog_init(dev, pcf2127);
 
+	/* Enable ultra-low power mode for PCF2131 (5-year battery life) */
+	if (pcf2127->cfg->type == PCF2131) {
+		ret = regmap_update_bits(pcf2127->regmap, PCF2127_REG_CTRL1,
+					 PCF2127_BIT_CTRL1_TC_DIS | PCF2127_BIT_CTRL1_100TH_S_DIS,
+					 PCF2127_BIT_CTRL1_TC_DIS | PCF2127_BIT_CTRL1_100TH_S_DIS);
+		if (ret) {
+			dev_err(dev, "failed to enable ultra-low power mode\n");
+		} else {
+			dev_info(dev, "PCF2131 ultra-low power mode enabled (~400nA)\n");
+		}
+		/* Don't fail probe if power optimization fails */
+		ret = 0;
+	}
+
 	/*
 	 * Disable battery low/switch-over timestamp and interrupts.
 	 * Clear battery interrupt flags which can block new trigger events.
@@ -1277,7 +1414,15 @@
 		return ret;
 	}
 
-	return devm_rtc_register_device(pcf2127->rtc);
+	ret = devm_rtc_register_device(pcf2127->rtc);
+	if (ret)
+		return ret;
+
+	/* Register SYSFS attributes for PCF2131 */
+	ret = pcf2127_sysfs_register(dev, pcf2127);
+	if (ret)
+		dev_warn(dev, "failed to create sysfs attributes: %d\n", ret);
+
+	return 0;
 }
 
 #ifdef CONFIG_OF