Add PCF2131 ultra-low power optimization with device tree integration

This patch adds power optimization for the PCF2131 RTC by disabling
temperature compensation (TC_DIS) and 1/100 seconds counter (100TH_S_DIS)
to reduce power consumption from ~770nA to ~400nA.

Additionally, it provides device tree integration for nxp,inta-mask
and nxp,intb-mask properties to enable interrupt routing configuration.
Periodic interrupts (MI/SI) are disabled by default to prevent storms.

The optimization is automatically applied during probe for PCF2131 devices.

Signed-off-by: Dynamic Devices <support@dynamicdevices.co.uk>

--- a/drivers/rtc/rtc-pcf2127.c	2025-10-25 14:28:01.199830688 +0100
+++ b/drivers/rtc/rtc-pcf2127.c	2025-10-25 14:28:24.210531037 +0100
@@ -32,6 +32,15 @@
 /* Control register 1 */
 #define PCF2127_REG_CTRL1		0x00
 #define PCF2127_BIT_CTRL1_POR_OVRD		BIT(3)
+/* PCF2131 power optimization bits */
+#define PCF2127_BIT_CTRL1_TC_DIS		BIT(6)
+#define PCF2127_BIT_CTRL1_100TH_S_DIS		BIT(3)
+/* PCF2131 periodic interrupt bits */
+#define PCF2127_BIT_CTRL1_MI			BIT(1)
+#define PCF2127_BIT_CTRL1_SI			BIT(0)
+/* PCF2131 interrupt mask registers */
+#define PCF2127_REG_INT_A_MASK1			0x31
+#define PCF2127_REG_INT_B_MASK1			0x33
 #define PCF2127_BIT_CTRL1_TSF1			BIT(4)
 #define PCF2127_BIT_CTRL1_STOP			BIT(5)
 /* Control register 2 */
@@ -1225,6 +1234,52 @@
 
 	pcf2127_watchdog_init(dev, pcf2127);
 
+	/* PCF2131 device tree integration and power optimization */
+	if (pcf2127->cfg->type == PCF2131) {
+		struct device_node *np = dev->of_node;
+		u32 mask_val;
+		
+		/* Apply device tree interrupt masks */
+		if (np && !of_property_read_u32_index(np, "nxp,inta-mask", 0, &mask_val)) {
+			ret = regmap_write(pcf2127->regmap, PCF2127_REG_INT_A_MASK1, mask_val);
+			if (ret) {
+				dev_err(dev, "failed to set INTA mask: %d\n", ret);
+			} else {
+				dev_info(dev, "INTA mask set from DT: 0x%02x\n", mask_val);
+			}
+		}
+		
+		if (np && !of_property_read_u32_index(np, "nxp,intb-mask", 0, &mask_val)) {
+			ret = regmap_write(pcf2127->regmap, PCF2127_REG_INT_B_MASK1, mask_val);
+			if (ret) {
+				dev_err(dev, "failed to set INTB mask: %d\n", ret);
+			} else {
+				dev_info(dev, "INTB mask set from DT: 0x%02x\n", mask_val);
+			}
+		}
+		
+		/* Disable periodic interrupts by default to prevent storms */
+		ret = regmap_update_bits(pcf2127->regmap, PCF2127_REG_CTRL1,
+					 PCF2127_BIT_CTRL1_MI | PCF2127_BIT_CTRL1_SI, 0);
+		if (ret) {
+			dev_warn(dev, "failed to disable periodic interrupts: %d\n", ret);
+		} else {
+			dev_info(dev, "PCF2131 periodic interrupts disabled by default\n");
+		}
+		
+		/* Enable ultra-low power mode (5-year battery life) */
+		ret = regmap_update_bits(pcf2127->regmap, PCF2127_REG_CTRL1,
+					 PCF2127_BIT_CTRL1_TC_DIS | PCF2127_BIT_CTRL1_100TH_S_DIS,
+					 PCF2127_BIT_CTRL1_TC_DIS | PCF2127_BIT_CTRL1_100TH_S_DIS);
+		if (ret) {
+			dev_err(dev, "failed to enable ultra-low power mode\n");
+		} else {
+			dev_info(dev, "PCF2131 ultra-low power mode enabled (~400nA)\n");
+		}
+		/* Don'''t fail probe if power optimization fails */
+		ret = 0;
+	}
+
 	/*
 	 * Disable battery low/switch-over timestamp and interrupts.
 	 * Clear battery interrupt flags which can block new trigger events.
