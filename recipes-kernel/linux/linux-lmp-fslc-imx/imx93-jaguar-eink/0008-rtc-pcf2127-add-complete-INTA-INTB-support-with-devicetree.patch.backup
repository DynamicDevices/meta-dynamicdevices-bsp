From 1234567890abcdef1234567890abcdef12345678 Mon Sep 17 00:00:00 2001
From: Dynamic Devices <support@dynamicdevices.co.uk>
Date: Mon, 21 Oct 2025 22:00:00 +0000
Subject: [PATCH] rtc: pcf2127: Add complete PCF2131 INTA/INTB support with device tree parsing

Add complete dual interrupt support for PCF2131 including sysfs interface and
automatic device tree configuration parsing for both INTA# and INTB# pins.

The PCF2131 supports dual interrupt outputs (INTA# and INTB#) that can be
independently configured for different interrupt sources. This patch adds:

1. Sysfs interface for runtime configuration of both interrupt pins
2. Device tree property parsing for automatic initialization
3. Support for PMU integration via INTB# line and system wake via INTA#
4. Automatic interrupt clearing via TI_TP bit for proper periodic interrupts
5. Sysfs control for MI/SI periodic interrupts (disabled by default)
6. Ultra-low power optimization (TC_DIS=1, 100TH_S_DIS=1, ~400nA)

Device tree usage:
    pcf2131: rtc@53 {
        compatible = "nxp,pcf2131";
        reg = <0x53>;
        interrupt-parent = <&gpio4>;
        interrupts = <22 IRQ_TYPE_LEVEL_LOW>, <23 IRQ_TYPE_LEVEL_LOW>;
        interrupt-names = "inta", "intb";
        nxp,inta-mask = <0x07 0x00>;  /* Alarms + battery on INTA# */
        nxp,intb-mask = <0x04 0x0F>;  /* Alarms + timestamps on INTB# */
        wakeup-source;
    };

Sysfs interface:
    /sys/class/rtc/rtc0/inta_mask1
    /sys/class/rtc/rtc0/inta_mask2
    /sys/class/rtc/rtc0/intb_mask1
    /sys/class/rtc/rtc0/intb_mask2
    /sys/class/rtc/rtc0/minute_interrupt  (0=disabled, 1=enabled)
    /sys/class/rtc/rtc0/second_interrupt  (0=disabled, 1=enabled)

This enables advanced power management scenarios where:
- INTA# connects to i.MX93 GPIO for system wake
- INTB# connects to PMU for deep sleep wake capability

Signed-off-by: Dynamic Devices <support@dynamicdevices.co.uk>
---
 drivers/rtc/rtc-pcf2127.c | 335 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 335 insertions(+)

--- a/drivers/rtc/rtc-pcf2127.c
+++ b/drivers/rtc/rtc-pcf2127.c
@@ -85,6 +85,14 >>
 enum pcf2127_type {
 	PCF2127,
 	PCF2129,
 	PCF21XX,
+	PCF2131,
 };
 
 struct pcf2127_cfg {
@@ -95,6 +103,10 >>
+static const struct pcf2127_cfg pcf2131_cfg = {
+	.type = PCF2131,
+	.max_register = 0x36,
+};
+
+@@ -100,6 +112,18 >>
 #define PCF2131_REG_SR_RESET		0x24
 #define PCF2131_REG_DWD_CTL		0x35
 
+/* PCF2131 interrupt mask registers */
+#define PCF2131_REG_INT_A_MASK1		0x31
+#define PCF2131_REG_INT_A_MASK2		0x32
+#define PCF2131_REG_INT_B_MASK1		0x33
+#define PCF2131_REG_INT_B_MASK2		0x34
+
+/* PCF2131 watchdog timer control register */
+#define PCF2131_REG_WATCHDG_TIM_CTL	0x35
+#define PCF2131_BIT_WATCHDG_TIM_CTL_TI_TP	BIT(1)
+
+/* PCF2131 Control_1 register bits for periodic interrupts */
+#define PCF2127_REG_CTRL1_MI		BIT(1)
+#define PCF2127_REG_CTRL1_SI		BIT(0)
+
+/* PCF2131 power optimization bits */
+#define PCF2127_REG_CTRL1_TC_DIS	BIT(6)
+#define PCF2127_REG_CTRL1_100TH_S_DIS	BIT(3)
+
 /* Control register 1 */
 #define PCF2127_REG_CTRL1_STOP		BIT(5)
 #define PCF2127_REG_CTRL1_TSF1		BIT(4)
@@ -905,6 +919,290 @@
 static DEVICE_ATTR_RW(timestamp2);
 static DEVICE_ATTR_RW(timestamp3);
 
+/* PCF2131 INTA mask sysfs interface */
+static ssize_t inta_mask1_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev->parent);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = regmap_read(pcf2127->regmap, PCF2131_REG_INT_A_MASK1, &val);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t inta_mask1_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev->parent);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 0xFF)
+		return -EINVAL;
+
+	ret = regmap_write(pcf2127->regmap, PCF2131_REG_INT_A_MASK1, val);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static ssize_t inta_mask2_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev->parent);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = regmap_read(pcf2127->regmap, PCF2131_REG_INT_A_MASK2, &val);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t inta_mask2_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev->parent);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 0xFF)
+		return -EINVAL;
+
+	ret = regmap_write(pcf2127->regmap, PCF2131_REG_INT_A_MASK2, val);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+/* PCF2131 INTB mask sysfs interface */
+static ssize_t intb_mask1_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev->parent);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = regmap_read(pcf2127->regmap, PCF2131_REG_INT_B_MASK1, &val);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t intb_mask1_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev->parent);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 0xFF)
+		return -EINVAL;
+
+	ret = regmap_write(pcf2127->regmap, PCF2131_REG_INT_B_MASK1, val);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static ssize_t intb_mask2_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev->parent);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = regmap_read(pcf2127->regmap, PCF2131_REG_INT_B_MASK2, &val);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "0x%02x\n", val);
+}
+
+static ssize_t intb_mask2_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev->parent);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 0xFF)
+		return -EINVAL;
+
+	ret = regmap_write(pcf2127->regmap, PCF2131_REG_INT_B_MASK2, val);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(inta_mask1);
+static DEVICE_ATTR_RW(inta_mask2);
+static DEVICE_ATTR_RW(intb_mask1);
+static DEVICE_ATTR_RW(intb_mask2);
+
+/* PCF2131 periodic interrupt control sysfs interface */
+static ssize_t minute_interrupt_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev->parent);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = regmap_read(pcf2127->regmap, PCF2127_REG_CTRL1, &val);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "%d\n", !!(val & PCF2127_REG_CTRL1_MI));
+}
+
+static ssize_t minute_interrupt_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev->parent);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 1)
+		return -EINVAL;
+
+	ret = regmap_update_bits(pcf2127->regmap, PCF2127_REG_CTRL1,
+				 PCF2127_REG_CTRL1_MI,
+				 val ? PCF2127_REG_CTRL1_MI : 0);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static ssize_t second_interrupt_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev->parent);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = regmap_read(pcf2127->regmap, PCF2127_REG_CTRL1, &val);
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "%d\n", !!(val & PCF2127_REG_CTRL1_SI));
+}
+
+static ssize_t second_interrupt_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev->parent);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 1)
+		return -EINVAL;
+
+	ret = regmap_update_bits(pcf2127->regmap, PCF2127_REG_CTRL1,
+				 PCF2127_REG_CTRL1_SI,
+				 val ? PCF2127_REG_CTRL1_SI : 0);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(minute_interrupt);
+static DEVICE_ATTR_RW(second_interrupt);
+
 static struct attribute *pcf2127_attrs[] = {
 	&dev_attr_timestamp0.attr,
 	NULL
@@ -921,6 +1127,12 @@
 	&dev_attr_timestamp1.attr,
 	&dev_attr_timestamp2.attr,
 	&dev_attr_timestamp3.attr,
+	&dev_attr_inta_mask1.attr,
+	&dev_attr_inta_mask2.attr,
+	&dev_attr_intb_mask1.attr,
+	&dev_attr_intb_mask2.attr,
+	&dev_attr_minute_interrupt.attr,
+	&dev_attr_second_interrupt.attr,
 	NULL
 };
 
@@ -1126,6 +1338,55 @@
 	pcf2127->rtc->range_max = RTC_TIMESTAMP_END_2099;
 	pcf2127->rtc->set_start_time = true; /* Sets actual start to 1970 */
 
+	/* Parse INTA and INTB mask configuration from device tree for PCF2131 */
+	if (pcf2127->cfg->type == PCF2131) {
+		u32 inta_mask[2], intb_mask[2];
+		
+		/* Configure INTA mask registers from device tree */
+		if (!of_property_read_u32_array(dev->of_node, "nxp,inta-mask", inta_mask, 2)) {
+			ret = regmap_write(pcf2127->regmap, PCF2131_REG_INT_A_MASK1, inta_mask[0]);
+			if (ret) {
+				dev_err(dev, "failed to set INTA mask1 from device tree\n");
+				return ret;
+			}
+			
+			ret = regmap_write(pcf2127->regmap, PCF2131_REG_INT_A_MASK2, inta_mask[1]);
+			if (ret) {
+				dev_err(dev, "failed to set INTA mask2 from device tree\n");
+				return ret;
+			}
+			
+			dev_info(dev, "INTA masks set from device tree: 0x%02x 0x%02x\n", 
+				 inta_mask[0], inta_mask[1]);
+		}
+		
+		/* Configure INTB mask registers from device tree */
+		if (!of_property_read_u32_array(dev->of_node, "nxp,intb-mask", intb_mask, 2)) {
+			ret = regmap_write(pcf2127->regmap, PCF2131_REG_INT_B_MASK1, intb_mask[0]);
+			if (ret) {
+				dev_err(dev, "failed to set INTB mask1 from device tree\n");
+				return ret;
+			}
+			
+			ret = regmap_write(pcf2127->regmap, PCF2131_REG_INT_B_MASK2, intb_mask[1]);
+			if (ret) {
+				dev_err(dev, "failed to set INTB mask2 from device tree\n");
+				return ret;
+			}
+			
+			dev_info(dev, "INTB masks set from device tree: 0x%02x 0x%02x\n", 
+				 intb_mask[0], intb_mask[1]);
+		}
+		
+		/* Enable TI_TP for automatic interrupt clearing (pulsed mode) */
+		ret = regmap_update_bits(pcf2127->regmap, PCF2131_REG_WATCHDG_TIM_CTL,
+					 PCF2131_BIT_WATCHDG_TIM_CTL_TI_TP,
+					 PCF2131_BIT_WATCHDG_TIM_CTL_TI_TP);
+		if (ret) {
+			dev_err(dev, "failed to enable TI_TP automatic interrupt clearing\n");
+			return ret;
+		}
+		
+		dev_info(dev, "TI_TP enabled for automatic interrupt clearing\n");
+		
+		/* Disable periodic interrupts by default to prevent interrupt storms */
+		ret = regmap_update_bits(pcf2127->regmap, PCF2127_REG_CTRL1,
+					 PCF2127_REG_CTRL1_MI | PCF2127_REG_CTRL1_SI,
+					 0);
+		if (ret) {
+			dev_err(dev, "failed to disable periodic interrupts\n");
+			return ret;
+		}
+		
+		dev_info(dev, "Periodic interrupts disabled by default (use sysfs to enable)\n");
+		
+		/* Enable ultra-low power mode for 5-year battery life */
+		ret = regmap_update_bits(pcf2127->regmap, PCF2127_REG_CTRL1,
+					 PCF2127_REG_CTRL1_TC_DIS | PCF2127_REG_CTRL1_100TH_S_DIS,
+					 PCF2127_REG_CTRL1_TC_DIS | PCF2127_REG_CTRL1_100TH_S_DIS);
+		if (ret) {
+			dev_err(dev, "failed to enable ultra-low power mode\n");
+			return ret;
+		}
+		
+		dev_info(dev, "Ultra-low power mode enabled (TC_DIS=1, 100TH_S_DIS=1, ~400nA)\n");
+	}
+
 	/*
 	 * PCF2127/29 do not work correctly when setting alarms at 1s intervals.
 	 * PCF2131 is ok.
@@ -1400,6 +1456,9 >>
 	{
 		.compatible = "nxp,pcf21xx",
 		.data = &pcf21xx_cfg
+	}, {
+		.compatible = "nxp,pcf2131",
+		.data = &pcf2131_cfg
 	},
 	{}
 };
@@ -1410,6 +1469,7 >>
 	{"pcf2127", (kernel_ulong_t)&pcf2127_cfg},
 	{"pcf2129", (kernel_ulong_t)&pcf2129_cfg},
 	{"pcf21xx", (kernel_ulong_t)&pcf21xx_cfg},
+	{"pcf2131", (kernel_ulong_t)&pcf2131_cfg},
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, pcf2127_i2c_id);
