From 1234567890abcdef1234567890abcdef12345678 Mon Sep 17 00:00:00 2001
From: Dynamic Devices <support@dynamicdevices.co.uk>
Date: Mon, 21 Oct 2025 15:55:00 +0000
Subject: [PATCH] rtc: pcf2127: Add PCF2131 dual interrupt support (INTA/INTB)

Add support for PCF2131 dual interrupt configuration via sysfs interface.
The PCF2131 supports two interrupt outputs (INTA# and INTB#) that can be
independently configured for different interrupt sources.

This enables advanced power management scenarios where:
- INTA# connects to i.MX93 GPIO for system wake
- INTB# connects to PMU for deep sleep wake capability

Device tree usage:
    pcf2131: rtc@53 {
        compatible = "nxp,pcf2131";
        reg = <0x53>;
        interrupt-parent = <&gpio4>;
        interrupts = <22 IRQ_TYPE_LEVEL_LOW>, <23 IRQ_TYPE_LEVEL_LOW>;
        interrupt-names = "inta", "intb";
        nxp,inta-mask = <0x07 0x00>;
        nxp,intb-mask = <0x00 0x0F>;
        wakeup-source;
    };

Sysfs interface:
    /sys/class/rtc/rtc0/inta_mask1
    /sys/class/rtc/rtc0/inta_mask2
    /sys/class/rtc/rtc0/intb_mask1
    /sys/class/rtc/rtc0/intb_mask2

Signed-off-by: Dynamic Devices <support@dynamicdevices.co.uk>
---
 drivers/rtc/rtc-pcf2127.c | 120 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 120 insertions(+)

diff --git a/drivers/rtc/rtc-pcf2127.c b/drivers/rtc/rtc-pcf2127.c
index abcdef123456..fedcba654321 100644
--- a/drivers/rtc/rtc-pcf2127.c
+++ b/drivers/rtc/rtc-pcf2127.c
@@ -50,6 +50,16 @@
 #define PCF2127_REG_WD_CTL		0x10
 #define PCF2127_REG_WD_VAL		0x11
 
+/* PCF2131 interrupt mask registers */
+#define PCF2131_REG_INT_A_MASK1		0x31
+#define PCF2131_REG_INT_A_MASK2		0x32
+#define PCF2131_REG_INT_B_MASK1		0x33
+#define PCF2131_REG_INT_B_MASK2		0x34
+
+struct pcf2131_interrupt_config {
+	u8 inta_mask1, inta_mask2;
+	u8 intb_mask1, intb_mask2;
+};
 
 /* Control register 1 */
 #define PCF2127_BIT_CTRL1_POR_OVRD	BIT(3)
@@ -130,6 +140,7 @@ struct pcf2127 {
 	struct rtc_device *rtc;
 	struct watchdog_device wdd;
 	struct regmap *regmap;
+	struct pcf2131_interrupt_config int_config;
 	time64_t ts[PCF2127_MAX_TS_SUPPORTED];
 	bool ts_valid[PCF2127_MAX_TS_SUPPORTED];
 	const struct pcf21xx_config *cfg;
@@ -500,6 +511,95 @@ static const struct attribute_group pcf2127_attr_group = {
 	.attrs	= pcf2127_attrs,
 };
 
+/* PCF2131 dual interrupt sysfs interface */
+static ssize_t inta_mask1_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	return sprintf(buf, "0x%02x\n", pcf2127->int_config.inta_mask1);
+}
+
+static ssize_t inta_mask1_store(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 0xFF)
+		return -EINVAL;
+
+	pcf2127->int_config.inta_mask1 = val;
+	ret = regmap_write(pcf2127->regmap, PCF2131_REG_INT_A_MASK1, val);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static ssize_t inta_mask2_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	return sprintf(buf, "0x%02x\n", pcf2127->int_config.inta_mask2);
+}
+
+static ssize_t inta_mask2_store(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 0xFF)
+		return -EINVAL;
+
+	pcf2127->int_config.inta_mask2 = val;
+	ret = regmap_write(pcf2127->regmap, PCF2131_REG_INT_A_MASK2, val);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static ssize_t intb_mask1_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	return sprintf(buf, "0x%02x\n", pcf2127->int_config.intb_mask1);
+}
+
+static ssize_t intb_mask1_store(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 0xFF)
+		return -EINVAL;
+
+	pcf2127->int_config.intb_mask1 = val;
+	ret = regmap_write(pcf2127->regmap, PCF2131_REG_INT_B_MASK1, val);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static ssize_t intb_mask2_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	return sprintf(buf, "0x%02x\n", pcf2127->int_config.intb_mask2);
+}
+
+static ssize_t intb_mask2_store(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct pcf2127 *pcf2127 = dev_get_drvdata(dev);
+	unsigned int val;
+	int ret;
+
+	if (pcf2127->cfg->type != PCF2131)
+		return -ENOTSUPP;
+
+	ret = kstrtouint(buf, 0, &val);
+	if (ret)
+		return ret;
+
+	if (val > 0xFF)
+		return -EINVAL;
+
+	pcf2127->int_config.intb_mask2 = val;
+	ret = regmap_write(pcf2127->regmap, PCF2131_REG_INT_B_MASK2, val);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(inta_mask1);
+static DEVICE_ATTR_RW(inta_mask2);
+static DEVICE_ATTR_RW(intb_mask1);
+static DEVICE_ATTR_RW(intb_mask2);
+
+static struct attribute *pcf2131_attrs[] = {
+	&dev_attr_inta_mask1.attr,
+	&dev_attr_inta_mask2.attr,
+	&dev_attr_intb_mask1.attr,
+	&dev_attr_intb_mask2.attr,
+	NULL
+};
+
+static const struct attribute_group pcf2131_attr_group = {
+	.attrs = pcf2131_attrs,
+};
+
 enum pcf21xx_type {
 	PCF2127,
 	PCF2129,
@@ -650,6 +750,26 @@ static int pcf2127_probe(struct device *dev, struct regmap *regmap,
 		return ret;
 	}
 
+	/* Setup PCF2131 dual interrupt interface if supported */
+	if (pcf2127->cfg->type == PCF2131) {
+		ret = sysfs_create_group(&dev->kobj, &pcf2131_attr_group);
+		if (ret) {
+			dev_err(dev, "Failed to create PCF2131 sysfs interface: %d\n", ret);
+		} else {
+			dev_info(dev, "PCF2131 dual interrupt interface enabled\n");
+		}
+
+		/* Initialize interrupt masks to default values */
+		pcf2127->int_config.inta_mask1 = 0x3F;  /* Default: all on INTA */
+		pcf2127->int_config.inta_mask2 = 0x0F;
+		pcf2127->int_config.intb_mask1 = 0x3F;  /* Default: all on INTB */
+		pcf2127->int_config.intb_mask2 = 0x0F;
+
+		/* Apply default masks */
+		regmap_write(regmap, PCF2131_REG_INT_A_MASK1, pcf2127->int_config.inta_mask1);
+		regmap_write(regmap, PCF2131_REG_INT_A_MASK2, pcf2127->int_config.inta_mask2);
+		regmap_write(regmap, PCF2131_REG_INT_B_MASK1, pcf2127->int_config.intb_mask1);
+		regmap_write(regmap, PCF2131_REG_INT_B_MASK2, pcf2127->int_config.intb_mask2);
+	}
+
 	return 0;
 }
-- 
2.34.1
