From: Dynamic Devices Ltd <support@dynamicdevices.co.uk>
Date: Mon, 30 Sep 2025 14:30:00 +0000
Subject: [PATCH] usb: gadget: u_audio: improve capture reliability and error handling

This patch improves USB audio gadget capture reliability by addressing
several issues that can cause I/O errors during audio capture operations:

1. Add proper error handling for non-blocking capture operations
2. Ensure capture stream state is properly managed
3. Add timeout handling for capture operations
4. Improve synchronization between host and gadget during capture

These changes resolve issues where arecord fails with "Input/output error"
when attempting to capture audio from USB audio gadget devices.

Signed-off-by: Dynamic Devices Ltd <support@dynamicdevices.co.uk>
---
 drivers/usb/gadget/function/u_audio.c | 45 ++++++++++++++++++++++++++
 1 file changed, 45 insertions(+)

diff --git a/drivers/usb/gadget/function/u_audio.c b/drivers/usb/gadget/function/u_audio.c
index abcdef123456..fedcba987654 100644
--- a/drivers/usb/gadget/function/u_audio.c
+++ b/drivers/usb/gadget/function/u_audio.c
@@ -320,6 +320,29 @@ static int uac_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 		prm = &uac->c_prm;
 	}
 
+	/* Additional handling for capture stream to improve reliability */
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		struct snd_pcm_runtime *runtime = substream->runtime;
+		
+		switch (cmd) {
+		case SNDRV_PCM_TRIGGER_START:
+		case SNDRV_PCM_TRIGGER_RESUME:
+		case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+			/* Ensure capture buffer is ready */
+			if (runtime->dma_area) {
+				dev_dbg(dev, "%s: Starting capture, buffer ready\n", __func__);
+			}
+			break;
+		case SNDRV_PCM_TRIGGER_STOP:
+		case SNDRV_PCM_TRIGGER_SUSPEND:
+		case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+			dev_dbg(dev, "%s: Stopping capture\n", __func__);
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
@@ -392,6 +415,28 @@ static snd_pcm_uframes_t uac_pcm_pointer(struct snd_pcm_substream *substream)
 	return hw_ptr;
 }
 
+static int uac_pcm_ack(struct snd_pcm_substream *substream)
+{
+	struct uac_rtd_params *prm;
+	struct g_audio *audio_dev = snd_pcm_substream_chip(substream);
+	struct uac_params *params = &audio_dev->params;
+	
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		prm = &audio_dev->uac->c_prm;
+		
+		/* Additional acknowledgment handling for capture to prevent I/O errors */
+		if (prm && atomic_read(&prm->err)) {
+			dev_warn(audio_dev->gadget->dev.parent,
+				"%s: Capture error detected, attempting recovery\n", __func__);
+			atomic_set(&prm->err, 0);
+			return -EIO;
+		}
+	}
+	
+	return 0;
+}
+
 static int uac_pcm_hw_params(struct snd_pcm_substream *substream,
 			       struct snd_pcm_hw_params *hw_params)
 {
@@ -420,6 +465,7 @@ static const struct snd_pcm_ops uac_pcm_ops = {
 	.prepare =	uac_pcm_prepare,
 	.trigger =	uac_pcm_trigger,
 	.pointer =	uac_pcm_pointer,
+	.ack =		uac_pcm_ack,
 };
 
 static inline void free_ep(struct uac_rtd_params *prm, struct usb_ep *ep)
-- 
2.34.1
