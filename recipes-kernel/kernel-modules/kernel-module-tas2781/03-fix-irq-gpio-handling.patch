commit 13f9218731801364eccc4052baa0a03e211c8870
Author: Alex J Lennon <ajlenon@dynamicdevices.co.uk>
Date:   Wed Sep 10 15:56:45 2025 +0100

    Fix TAS2781 driver IRQ handling bug
    
    The driver was incorrectly treating IRQ numbers as GPIO numbers,
    causing 'GPIO request error' when using standard interrupt bindings.
    
    Changes:
    - Remove incorrect gpio_request/gpio_to_irq sequence in tasdevice-core.c
    - Use IRQ number directly from of_irq_get() with request_threaded_irq()
    - Update IRQ validity checks from gpio_is_valid(irq_gpio) to irq > 0
    - Fix IRQ handling in tasdevice-codec.c and tasdevice-misc.c
    
    This resolves the error:
    'tasdevice_parse_dt_reset_irq_pin: GPIO 173 request error'
    
    The driver now properly uses the Linux interrupt framework with
    standard device tree interrupt bindings:
      interrupt-parent = <&gpio5>;
      interrupts = <5 IRQ_TYPE_LEVEL_LOW>;
    
    Tested with: TAS2563 on imx8mm-jaguar-sentai board

diff --git a/src/tasdevice-codec.c b/src/tasdevice-codec.c
index eb62f1d..60da23c 100644
--- a/src/tasdevice-codec.c
+++ b/src/tasdevice-codec.c
@@ -260,7 +260,7 @@ void powercontrol_routine(struct work_struct *work)
 	tasdevice_select_cfg_blk(tas_dev, profile_cfg_id,
 		TASDEVICE_BIN_BLK_PRE_POWER_UP);
 
-	if (gpio_is_valid(tas_dev->irq_info.irq_gpio))
+	if (tas_dev->irq_info.irq > 0)
 		tasdevice_enable_irq(tas_dev, true);
 	mutex_unlock(&tas_dev->codec_lock);
 out:
@@ -289,7 +289,7 @@ static void tasdevice_set_power_state(
 		break;
 	default:
 		if (!(tas_dev->pstream || tas_dev->cstream)) {
-			if (gpio_is_valid(tas_dev->irq_info.irq_gpio))
+			if (tas_dev->irq_info.irq > 0)
 				tasdevice_enable_irq(tas_dev, false);
 			tasdevice_select_cfg_blk(tas_dev,
 				tas_dev->mtRegbin.profile_cfg_id,
diff --git a/src/tasdevice-core.c b/src/tasdevice-core.c
index ffb6ef3..fcfd02c 100644
--- a/src/tasdevice-core.c
+++ b/src/tasdevice-core.c
@@ -127,7 +127,7 @@ void tasdevice_enable_irq(struct tasdevice_priv *tas_dev,
 	bool enable)
 {
 	if (enable != tas_dev->irq_info.irq_enable &&
-		!gpio_is_valid(tas_dev->irq_info.irq_gpio))
+		tas_dev->irq_info.irq <= 0)
 		return;
 
 	if (enable)
@@ -183,43 +183,28 @@ void tasdevice_parse_dt_reset_irq_pin(
 	if (IS_ERR(tas_priv->reset))
 		dev_err(tas_priv->dev, "%s Can't get reset GPIO\n", __func__);
 
-	tas_priv->irq_info.irq_gpio = of_irq_get(np, 0);
-	if (gpio_is_valid(tas_priv->irq_info.irq_gpio)) {
-		dev_info(tas_priv->dev, "irq-gpio = %d",
-			tas_priv->irq_info.irq_gpio);
+	tas_priv->irq_info.irq = of_irq_get(np, 0);
+	if (tas_priv->irq_info.irq > 0) {
+		dev_info(tas_priv->dev, "irq = %d", tas_priv->irq_info.irq);
 		INIT_DELAYED_WORK(&tas_priv->irq_info.irq_work,
 			irq_work_routine);
 		tas_priv->irq_info.irq_enable = false;
 
-		rc = gpio_request(tas_priv->irq_info.irq_gpio, "AUDEV-IRQ");
-		if (!rc) {
-			gpio_direction_input(tas_priv->irq_info.irq_gpio);
-
-			tas_priv->irq_info.irq =
-				gpio_to_irq(tas_priv->irq_info.irq_gpio);
-			dev_info(tas_priv->dev, "irq = %d\n",
-				tas_priv->irq_info.irq);
-
-			rc = request_threaded_irq(tas_priv->irq_info.irq,
-				tasdevice_irq_handler, NULL,
-				IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
-				tas_priv->dev_name, tas_priv);
-			if (!rc)
-				disable_irq_nosync(tas_priv->irq_info.irq);
-			else
-				dev_err(tas_priv->dev,
-					"request_irq failed, %d\n", rc);
-		} else
+		rc = request_threaded_irq(tas_priv->irq_info.irq,
+			tasdevice_irq_handler, NULL,
+			IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+			tas_priv->dev_name, tas_priv);
+		if (!rc)
+			disable_irq_nosync(tas_priv->irq_info.irq);
+		else
 			dev_err(tas_priv->dev,
-				"%s: GPIO %d request error\n",
-				__func__,
-				tas_priv->irq_info.irq_gpio);
+				"request_irq failed, %d\n", rc);
 	} else
-		dev_err(tas_priv->dev, "Looking up irq gpio property "
+		dev_err(tas_priv->dev, "Looking up irq property "
 			"in node %s failed %d, no side effect on driver running\n",
-			np->full_name, tas_priv->irq_info.irq_gpio);
+			np->full_name, tas_priv->irq_info.irq);
 
-	if (gpio_is_valid(tas_priv->irq_info.irq_gpio)) {
+	if (tas_priv->irq_info.irq > 0) {
 		switch (tas_priv->chip_id) {
 		case TAS2563:
 			tas_priv->irq_work_func = tas2563_irq_work_func;
@@ -330,7 +315,7 @@ static int tasdevice_pm_suspend(struct device *dev)
 
 	tas_dev->mb_runtime_suspend = true;
 
-	if (gpio_is_valid(tas_dev->irq_info.irq_gpio)) {
+	if (tas_dev->irq_info.irq > 0) {
 		if (delayed_work_pending(&tas_dev->irq_info.irq_work)) {
 			dev_dbg(tas_dev->dev, "cancel IRQ work\n");
 			cancel_delayed_work_sync(&tas_dev->irq_info.irq_work);
diff --git a/src/tasdevice-misc.c b/src/tasdevice-misc.c
index c43aff4..d1a069e 100644
--- a/src/tasdevice-misc.c
+++ b/src/tasdevice-misc.c
@@ -553,7 +553,7 @@ static long tasdevice_ioctl(struct file *f,
 	if (tas_dev->pstream != 0 && tas_dev->cstream == 0) {
 		tas_dev->pstream = 0;
 		mutex_lock(&tas_dev->codec_lock);
-		if (gpio_is_valid(tas_dev->irq_info.irq_gpio))
+		if (tas_dev->irq_info.irq > 0)
 			tasdevice_enable_irq(tas_dev, false);
 		tasdevice_select_cfg_blk(tas_dev, tas_dev->cur_conf,
 			TASDEVICE_BIN_BLK_PRE_SHUTDOWN);
