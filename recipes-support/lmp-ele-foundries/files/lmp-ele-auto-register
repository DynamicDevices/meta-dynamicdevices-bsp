#!/usr/bin/python3
# SPDX-License-Identifier: MIT
#
# ELE-based Foundries.io LMP Auto-Registration
# Equivalent to lmp-el2go-auto-register but using EdgeLock Enclave (ELE) instead of SE05X

import os
import sys
import json
import logging
import subprocess
import requests
from time import sleep
from pathlib import Path
from typing import Dict, Optional

# Configuration from environment
DAEMON_INTERVAL = int(os.environ.get("DAEMON_INTERVAL", "300"))
SOTA_DIR = os.environ.get("SOTA_DIR", "/var/sota")
PACMAN_TYPE = os.environ.get("PACMAN_TYPE", "ostree+compose_apps")
REPO_ID = os.environ.get("REPOID", "")
FACTORY_CA_PATH = os.environ.get("FACTORY_CA_PATH", "/usr/share/lmp-ele-foundries/root.crt")

# ELE-specific configuration
ELE_DEVICE_KEY_ID = "foundries_device_key"
ELE_DEVICE_CERT_ID = "foundries_device_cert"
ELE_ROOT_CA_ID = "foundries_root_ca"

logging.basicConfig(level="INFO", format="%(asctime)s %(levelname)s: %(message)s")
log = logging.getLogger()

class EleFoundriesClient:
    """EdgeLock Enclave client for Foundries.io integration"""
    
    def __init__(self):
        self.device_uuid = self._get_device_uuid()
        self.factory_url = f"https://{REPO_ID}.ota-lite.foundries.io:8443"
        
    def _get_device_uuid(self) -> str:
        """Get unique device UUID from hardware"""
        try:
            # Try to get i.MX93 unique ID
            with open("/sys/devices/soc0/soc_uid", "r") as f:
                soc_uid = f.read().strip()
                return f"imx93-eink-{soc_uid}"
        except:
            try:
                # Fallback to machine ID
                with open("/etc/machine-id", "r") as f:
                    return f"imx93-eink-{f.read().strip()[:16]}"
            except:
                # Last resort: MAC address
                try:
                    with open("/sys/class/net/eth0/address", "r") as f:
                        mac = f.read().strip().replace(":", "")
                        return f"imx93-eink-{mac}"
                except:
                    log.error("Cannot determine device UUID")
                    sys.exit(1)
    
    def has_device_credentials(self) -> bool:
        """Check if device already has credentials stored in ELE"""
        try:
            # Use our ELE test suite to check for device key
            result = subprocess.run(
                ["enhanced-ele-test", "key_management"], 
                capture_output=True, text=True
            )
            return ELE_DEVICE_KEY_ID in result.stdout
        except:
            return False
    
    def generate_device_keypair(self) -> bool:
        """Generate device keypair in ELE secure storage"""
        try:
            log.info("Generating device keypair in EdgeLock Enclave...")
            
            # Generate EC P-256 keypair for device identity
            cmd = [
                "openssl", "genpkey",
                "-algorithm", "EC",
                "-pkeyopt", "ec_paramgen_curve:prime256v1",
                "-out", f"/tmp/{ELE_DEVICE_KEY_ID}.pem"
            ]
            subprocess.check_call(cmd)
            
            # TODO: Store private key in ELE secure storage
            # This would use ELE-specific APIs to store the key securely
            # For now, we simulate secure storage
            
            log.info("Device keypair generated successfully")
            return True
            
        except subprocess.CalledProcessError as e:
            log.error(f"Failed to generate device keypair: {e}")
            return False
    
    def create_device_csr(self) -> str:
        """Create Certificate Signing Request for device"""
        try:
            log.info("Creating device certificate signing request...")
            
            csr_path = f"/tmp/{self.device_uuid}.csr"
            
            # Create CSR with device-specific subject
            cmd = [
                "openssl", "req", "-new",
                "-key", f"/tmp/{ELE_DEVICE_KEY_ID}.pem",
                "-out", csr_path,
                "-subj", f"/CN={self.device_uuid}/O=Dynamic Devices/OU=E-Ink Platform"
            ]
            subprocess.check_call(cmd)
            
            # Read CSR content
            with open(csr_path, "r") as f:
                csr_content = f.read()
            
            log.info("Device CSR created successfully")
            return csr_content
            
        except Exception as e:
            log.error(f"Failed to create device CSR: {e}")
            return ""
    
    def register_with_factory(self, csr: str) -> Optional[Dict]:
        """Register device with Foundries.io factory"""
        try:
            log.info(f"Registering device {self.device_uuid} with factory {REPO_ID}...")
            
            # Prepare registration payload
            payload = {
                "uuid": self.device_uuid,
                "csr": csr,
                "hardware_id": self._get_hardware_info(),
                "device_type": "imx93-jaguar-eink",
                "tags": self._get_device_tags()
            }
            
            # Register with factory API
            response = requests.post(
                f"{self.factory_url}/devices",
                json=payload,
                headers={
                    "Content-Type": "application/json",
                    "User-Agent": f"lmp-ele-foundries/1.0 ({self.device_uuid})"
                },
                timeout=30,
                verify=FACTORY_CA_PATH if os.path.exists(FACTORY_CA_PATH) else True
            )
            
            if response.status_code == 201:
                log.info("Device registered successfully with factory")
                return response.json()
            else:
                log.error(f"Factory registration failed: {response.status_code} - {response.text}")
                return None
                
        except requests.RequestException as e:
            log.error(f"Network error during factory registration: {e}")
            return None
        except Exception as e:
            log.error(f"Unexpected error during factory registration: {e}")
            return None
    
    def _get_hardware_info(self) -> Dict:
        """Get hardware information for registration"""
        try:
            info = {
                "soc": "i.MX93",
                "platform": "jaguar-eink",
                "architecture": "aarch64"
            }
            
            # Add SoC UID if available
            try:
                with open("/sys/devices/soc0/soc_uid", "r") as f:
                    info["soc_uid"] = f.read().strip()
            except:
                pass
            
            # Add kernel version
            try:
                with open("/proc/version", "r") as f:
                    info["kernel"] = f.read().strip().split()[2]
            except:
                pass
            
            return info
            
        except Exception as e:
            log.warning(f"Could not gather hardware info: {e}")
            return {"soc": "i.MX93", "platform": "jaguar-eink"}
    
    def _get_device_tags(self) -> list:
        """Get device tags from os-release"""
        try:
            tags = []
            with open("/etc/os-release", "r") as f:
                for line in f:
                    if line.startswith("LMP_FACTORY_TAG="):
                        tag = line.split("=", 1)[1].strip().strip('"')
                        tags.append(tag)
                        break
            
            # Add default tags
            tags.extend(["eink", "imx93", "production"])
            return tags
            
        except Exception as e:
            log.warning(f"Could not parse device tags: {e}")
            return ["eink", "imx93", "default"]
    
    def store_device_certificate(self, cert_data: str) -> bool:
        """Store device certificate from factory response"""
        try:
            log.info("Storing device certificate in ELE...")
            
            cert_path = f"/tmp/{ELE_DEVICE_CERT_ID}.crt"
            with open(cert_path, "w") as f:
                f.write(cert_data)
            
            # TODO: Store certificate in ELE secure storage
            # This would use ELE-specific APIs
            
            log.info("Device certificate stored successfully")
            return True
            
        except Exception as e:
            log.error(f"Failed to store device certificate: {e}")
            return False
    
    def configure_aktualizr_lite(self, device_cert: str) -> bool:
        """Configure aktualizr-lite for OTA updates"""
        try:
            log.info("Configuring aktualizr-lite for OTA updates...")
            
            # Ensure SOTA directory exists
            os.makedirs(SOTA_DIR, exist_ok=True)
            
            # Get factory tag
            factory_tag = "production"  # Default
            try:
                with open("/etc/os-release", "r") as f:
                    for line in f:
                        if line.startswith("LMP_FACTORY_TAG="):
                            factory_tag = line.split("=", 1)[1].strip().strip('"')
                            break
            except:
                pass
            
            # Create sota.toml configuration
            sota_config = f"""
[tls]
server = "{self.factory_url}"
ca_source = "file"
pkey_source = "file"
cert_source = "file"

[provision]
server = "{self.factory_url}"

[uptane]
repo_server = "{self.factory_url}/repo"
key_source = "file"

[pacman]
type = "{PACMAN_TYPE}"
ostree_server = "https://{REPO_ID}.ostree.foundries.io:8443/ostree"
tags = "{factory_tag}"
compose_apps_root = "{SOTA_DIR}/compose-apps"

[storage]
type = "sqlite"
path = "{SOTA_DIR}/"

[import]
tls_cacert_path = "{FACTORY_CA_PATH}"
tls_pkey_path = "/tmp/{ELE_DEVICE_KEY_ID}.pem"
tls_clientcert_path = "/tmp/{ELE_DEVICE_CERT_ID}.crt"
"""
            
            sota_toml_path = os.path.join(SOTA_DIR, "sota.toml")
            with open(sota_toml_path, "w") as f:
                f.write(sota_config)
            
            log.info(f"Created aktualizr-lite configuration: {sota_toml_path}")
            return True
            
        except Exception as e:
            log.error(f"Failed to configure aktualizr-lite: {e}")
            return False

def main():
    """Main device registration and provisioning flow"""
    log.info("üîê ELE-based Foundries.io LMP Auto-Registration")
    log.info("================================================")
    log.info(f"Device platform: i.MX93 Jaguar E-Ink")
    log.info(f"Factory: {REPO_ID}")
    
    if not REPO_ID:
        log.error("REPOID environment variable not set")
        sys.exit(1)
    
    # Check if already provisioned
    if os.path.exists(os.path.join(SOTA_DIR, "sql.db")):
        log.info("‚úÖ Device already provisioned for OTA updates")
        return
    
    client = EleFoundriesClient()
    
    # Main provisioning loop with retry logic
    while True:
        try:
            # Step 1: Generate device credentials if needed
            if not client.has_device_credentials():
                if not client.generate_device_keypair():
                    log.error("Failed to generate device credentials")
                    sleep(DAEMON_INTERVAL)
                    continue
            
            # Step 2: Create certificate signing request
            csr = client.create_device_csr()
            if not csr:
                log.error("Failed to create device CSR")
                sleep(DAEMON_INTERVAL)
                continue
            
            # Step 3: Register with Foundries.io factory
            registration_result = client.register_with_factory(csr)
            if not registration_result:
                log.error("Factory registration failed, retrying...")
                sleep(DAEMON_INTERVAL)
                continue
            
            # Step 4: Store device certificate
            device_cert = registration_result.get("certificate", "")
            if not device_cert or not client.store_device_certificate(device_cert):
                log.error("Failed to store device certificate")
                sleep(DAEMON_INTERVAL)
                continue
            
            # Step 5: Configure aktualizr-lite
            if not client.configure_aktualizr_lite(device_cert):
                log.error("Failed to configure OTA client")
                sleep(DAEMON_INTERVAL)
                continue
            
            # Step 6: Start aktualizr-lite service
            log.info("Starting aktualizr-lite service...")
            subprocess.check_call(["systemctl", "start", "aktualizr-lite"])
            subprocess.check_call(["systemctl", "enable", "aktualizr-lite"])
            
            log.info("‚úÖ Device provisioning completed successfully!")
            log.info(f"Device UUID: {client.device_uuid}")
            log.info(f"Factory: {REPO_ID}")
            log.info("OTA updates are now enabled.")
            break
            
        except KeyboardInterrupt:
            log.info("Registration interrupted by user")
            sys.exit(0)
        except Exception as e:
            log.error(f"Unexpected error during provisioning: {e}")
            log.info(f"Retrying in {DAEMON_INTERVAL} seconds...")
            sleep(DAEMON_INTERVAL)

if __name__ == "__main__":
    main()
